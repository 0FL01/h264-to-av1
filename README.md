### Сделано для RX 780M + 7840HS


# H264 → AV1 Video Converter (Linux)

Скрипт для автоматического перекодирования H264 (MP4/MKV) в AV1 с аппаратным ускорением VAAPI:

| Скрипт | Платформа | Кодек | Энкодер |
|--------|-----------|-------|---------|
| `convert_linux.py` | Linux | AV1 | VAAPI (av1_vaapi) |

Скрипт автоматически подбирает битрейт под исходник, сохраняет баланс качества и размера, работает интерактивно и безопасно (атомарные записи, очистка временных файлов).

## Общие возможности
- Автоматический расчёт целевого битрейта: учёт исходного битрейта, разрешения и защитные минимумы/максимумы.
- Работа с одиночными файлами и папками: поиск видео, предложение путей сохранения.
- Прогресс-бар во время конвертации, итоговая статистика экономии места.
- Адаптивный GOP: ~10 секунд (`FPS * 10`) и `keyint_min ≈ FPS` для нормальной перемотки без потери эффективности сжатия.
- Безопасный выходной контейнер: всегда `mkv` для совместимости с субтитрами, шрифтами и вложениями.
- Пропуск файлов `AV1`/`H265` и опциональное копирование их в выходную папку.
- Быстрые ответы на конфликт имён (RU/EN подсказка): д/н/в/п или y/n/a/s — можно перезаписать все, пропустить все или решить точечно.
- Сохранение субтитров, метаданных и глав: `-map 0`, `-map_metadata 0`, `-map_chapters 0`, копирование аудио/субтитров без рекодирования.
- Атомарность: запись во временный файл и перенос после успеха; корректная очистка при отмене.

---

## Linux: H264 → AV1 (VAAPI)

### Особенности Linux-версии
- Аппаратное кодирование AV1 через `av1_vaapi`, декодирование на CPU.
- 10-битный pipeline (p010) для меньшего бандинга и ~5–10% лучшего сжатия даже у 8-битных источников.
- Суффикс выходного файла: `-av1.mkv`

## Требования
- Python 3.12+
- `ffmpeg` и `ffprobe` с поддержкой VAAPI и кодека `av1_vaapi`.
- Драйвер VAAPI для вашего GPU (`intel-media-va-driver` или `libva-mesa-driver`).
- Доступ к устройству `/dev/dri/renderD128` (VAAPI render node).

### Важно про железо
Скрипт сознательно заточен под конкретную конфигурацию VAAPI-ускорителя и проверенные параметры:
- Жёстко задано устройство `va:/dev/dri/renderD128` и 10-битный пайплайн `cas=strength=0.3,format=p010le,hwupload`.
- VBR-настройки и GOP: `-rc_mode VBR`, адаптивный `-g` (≈10 секунд по FPS), `-keyint_min` (≈ FPS), `-bf 7`, `-async_depth 4`.
- Эвристика битрейта: сохраняет ~65% исходного H264-битрейта с порогами по разрешениям (минимумы/верхние пределы).
Если у вас другое GPU/драйвер или путь render node, адаптируйте параметры в `convert_linux.py` под свою систему.

### Установка ffmpeg c VAAPI (пример для Fedora)
```bash
sudo dnf install ffmpeg ffmpeg-libs libva libva-utils
vainfo
ffmpeg -encoders | grep vaapi
```

### Запуск Linux-версии
```bash
python3 convert_linux.py
```
Скрипт спросит путь к файлу или папке, предложит место сохранения (по умолчанию рядом, с суффиксом `-av1.mkv`), подтвердит старт и покажет прогресс.

---

## Сохранение субтитров и метаданных
- В команде `ffmpeg` используется маппинг всех потоков `-map 0`, плюс `-map_metadata 0` и `-map_chapters 0`, чтобы не терять теги и главы.
- Аудио/субтитры копируются (`-c:a copy`, `-c:s copy`) без перекодирования. Встроенные вложения/шрифты (`-c:t copy`) также копируются.
- Контейнер по умолчанию — `mkv`, чтобы не терять вложения и редкие типы субтитров; mp4 может завершиться ошибкой на таких потоках.

---

## Как работает подбор битрейта

### AV1 (Linux)
1. `ffprobe` читает codec/bitrate/FPS/разрешение/длительность. Если битрейт не найден, вычисляется из размера файла.
2. Целевой битрейт считается нелинейно (степенная кривая `target = 6 * bitrate^0.72` в kbps), затем ограничивается порогами:
   - 4K: 8 000–25 000 kbps
   - 1440p: 4 000–15 000 kbps
   - 1080p: 2 000–8 000 kbps
   - 720p: 1 000–5 000 kbps
   - SD и ниже: 500–3 000 kbps
3. `maxrate = target × 1.6`, `bufsize = target × 2`

### Почему не BPP, а степенная кривая по битрейту
BPP (bits-per-pixel) даёт фиксированное отношение к разрешению и FPS и слабо учитывает «эффективность» исходника: шум/грейн, уже применённые фильтры, качество исходной компрессии. Степенная функция по фактическому битрейту источника (с мягким сглаживанием за счёт степени < 1 и защитных порогов) лучше отражает реальную сложность контента: она агрессивнее урезает избыточно «жирные» исходники и аккуратнее ведёт себя на уже сжатых/чистых. В моих типовых кейсах это даёт ~20–30% меньше итоговый размер при том же визуальном качестве по сравнению с BPP-эвристикой, плюс меньше ручной подстройки под разные сцены и источники.

### Почему VBR, а не CQP/CRF
Для VAAPI-энкодера выбран VBR с ручным таргетом/порогами. В моих кейсах CQP/CRF (CPQ) на тех же исходниках даёт либо рост размера без выигрыша в картинке, либо требует частых ручных подстроек под сцены. VBR с текущими порогами и буфером даёт стабильнее контролируемый размер, при этом картинка сопоставима или лучше, а итоговые файлы заметно меньше оригинала.

## Поведение при пакетной обработке
- Список найденных файлов выводится перед стартом.
- После завершения показывается агрегированная статистика (успехи/ошибки/пропуски, общий выигрыш по размеру).
- При наличии пропущенных `AV1/H265` файлов можно скопировать их в выходную папку, чтобы собрать полный сет.

## Безопасность и отмена
- Прерывания (Ctrl+C, SIGTERM) отлавливаются: текущий `ffmpeg` завершается, временный файл удаляется, исходник не трогается.
- Используется временный файл с последующим атомарным `move`, чтобы не оставить частично записанных результатов.

## Мини-FAQ

### Linux (AV1)
- **Ничего не происходит?** Проверьте доступ к `/dev/dri/renderD128` и наличие `av1_vaapi` в `ffmpeg -encoders`.
- **Другое GPU/путь устройства?** Отредактируйте параметры `-init_hw_device`, `-filter_hw_device` и фильтр `-vf` в `convert_linux.py`.
- **Хотите ручной контроль битрейта?** Меняйте коэффициенты `alpha`, `scale` и пороги в функции `calculate_av1_bitrate`.
